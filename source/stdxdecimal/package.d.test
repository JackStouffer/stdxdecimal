/*
    Adapted from the reference implementation of the General Decimal Arithmetic
    specification from the international Components for Unicode under the 
    permissive ICU License.

    This implementation is rewritten for the D Programming Language and is
    relicensed under the Boost Software License 1.0 and is written by Jack Stouffer
*/

module stdxdecimaltest;

import std.stdio;
import core.stdc.stdlib;
import std.traits;

enum DECNUMDIGITS = 40;
enum DECDPUN = 3;
enum DECNUMUNITS = ((DECNUMDIGITS + DECDPUN - 1) / DECDPUN);
enum DECBUFFER = 36;
enum DECCHECK = false; /* 1 to enable robust checking */

/* Initialization descriptors, used by decContextDefault */
enum DEC_INIT_BASE = 0;
enum DEC_INIT_DECIMAL32 = 32;
enum DEC_INIT_DECIMAL64 = 64;
enum DEC_INIT_DECIMAL128 = 128;
/* Synonyms */
enum DEC_INIT_DECSINGLE = DEC_INIT_DECIMAL32;
enum DEC_INIT_DECDOUBLE = DEC_INIT_DECIMAL64;
enum DEC_INIT_DECQUAD = DEC_INIT_DECIMAL128;

enum DECNEG = 0x80; /* Sign; 1=negative, 0=positive or zero */
enum DECINF = 0x40; /* 1=Infinity */
enum DECNAN = 0x20; /* 1=NaN */
enum DECSNAN = 0x10; /* 1=sNaN */
enum DECSPECIAL = (DECINF | DECNAN | DECSNAN); /* any special value     */

enum DECSUBSET = false;
enum DECEXTFLAG = false; /* 1=enable extended flags */

static if (DECDPUN <= 2)
    alias decNumberuint = ubyte;
else static if (DECDPUN <= 4)
    alias decNumberuint = ushort;
else
    alias decNumberuint = int;

private auto SD2U(int d)
{
    return ((d) + DECDPUN - 1) / DECDPUN;
}

static if (DECDPUN == 1)
{
    enum DECDPUNMAX = 9;
    enum D2UTABLE = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
            33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49];
}
else static if (DECDPUN == 2)
{
    enum DECDPUNMAX = 99;
    enum D2UTABLE = [0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
            10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17,
            18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25];
}
else static if (DECDPUN == 3)
{
    enum DECDPUNMAX = 999;
    enum D2UTABLE = [0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6,
            7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,
            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17];
}
else static if (DECDPUN == 4)
{
    enum DECDPUNMAX = 9999;
    enum D2UTABLE = [0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,
            5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10,
            10, 11, 11, 11, 11, 12, 12, 12, 12, 13];
}
else static if (DECDPUN == 5)
{
    enum DECDPUNMAX = 99999;
    enum D2UTABLE = [0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4,
            4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,
            9, 9, 9, 9, 9, 10, 10, 10, 10];
}
else static if (DECDPUN == 6)
{
    enum DECDPUNMAX = 999999;
    enum D2UTABLE = [0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
            4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7,
            7, 7, 8, 8, 8, 8, 8, 8, 9];
}
else static if (DECDPUN == 7)
{
    enum DECDPUNMAX = 9999999;
    enum D2UTABLE = [0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
            3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
            6, 6, 7, 7, 7, 7, 7, 7, 7];
}
else static if (DECDPUN == 8)
{
    enum DECDPUNMAX = 99999999;
    enum D2UTABLE = [0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3,
            3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
            6, 6, 6, 6, 6, 6, 6, 6, 7];
}
else static if (DECDPUN == 9)
{
    enum DECDPUNMAX = 999999999;
    enum D2UTABLE = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 6, 6, 6, 6];
}
else
{
    static assert(0, "DECDPUN must be in the range 1-9");
}

static immutable uint[10] DECPOWERS = [
    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
];
alias powers = DECPOWERS;

/* Public lookup table used by the D2U macro (see below) */
enum DECMAXD2U = 49;
static immutable ubyte[DECMAXD2U + 1] d2utable = D2UTABLE;
/* D2U -- return the number of uints needed to hold d digits */
/* (runtime version, with table lookaside for small d) */
static if (DECDPUN == 8)
{
    auto D2U(T)(T d)
    {
        return cast(unsigned)((d) <= DECMAXD2U ? d2utable[d] : ((d) + 7) >> 3);
    }
}
else static if (DECDPUN == 4)
{
    auto D2U(T)(T d)
    {
        return cast(unsigned)((d) <= DECMAXD2U ? d2utable[d] : ((d) + 3) >> 2);
    }
}
else
{
    auto D2U(T)(T d)
    {
        return (d) <= DECMAXD2U ? d2utable[d] : ((d) + DECDPUN - 1) / DECDPUN;
    }
}

private ubyte decBiStr(const(char)* targ, const(char)* str1, const(char)* str2)
{
    for (;; targ++, str1++, str2++)
    {
        if (*targ != *str1 && *targ != *str2)
            return 0;
        // *targ has a match in one (or both, if terminator)
        if (*targ == '\0')
            break;
    } // forever
    return 1;
}

static immutable uint[] multies = [131073, 26215, 5243, 1049, 210];
auto QUOT10(T, V)(T u, V n)
{
    return ((cast(uint)(u) >> (n)) * multies[n]) >> 17;
}

enum Rounding
{
    DEC_ROUND_CEILING, /* round towards +infinity         */
    DEC_ROUND_UP, /* round away from 0               */
    DEC_ROUND_HALF_UP, /* 0.5 rounds up                   */
    DEC_ROUND_HALF_EVEN, /* 0.5 rounds to nearest even      */
    DEC_ROUND_HALF_DOWN, /* 0.5 rounds down                 */
    DEC_ROUND_DOWN, /* round towards 0 (truncate)      */
    DEC_ROUND_FLOOR, /* round towards -infinity         */
    DEC_ROUND_05UP, /* round for reround               */
    DEC_ROUND_MAX /* enum must be less than this     */
}

enum DEC_ROUND_DEFAULT = Rounding.DEC_ROUND_HALF_UP;

enum DEC_MAX_DIGITS = 999999999;
enum DEC_MIN_DIGITS = 1;
enum DEC_MAX_EMAX = 999999999;
enum DEC_MIN_EMAX = 0;
enum DEC_MAX_EMIN = 0;
enum DEC_MIN_EMIN = -999999999;
enum DEC_MAX_MATH = 999999;

enum DECNUMMAXP = 999999999; /* maximum precision code can handle  */
enum DECNUMMAXE = 999999999; /* maximum adjusted exponent ditto    */
enum DECNUMMINE = -999999999; /* minimum adjusted exponent ditto    */
static if (DECNUMMAXP != DEC_MAX_DIGITS)
{
    static assert(0, "Maximum digits mismatch");
}
static if (DECNUMMAXE != DEC_MAX_EMAX)
{
    static assert(0, "Maximum exponent mismatch");
}
static if (DECNUMMINE != DEC_MIN_EMIN)
{
    static assert(0, "Minimum exponent mismatch");
}

static if (DECEXTFLAG)
{
    /* Extended flags */
    enum DEC_Conversion_syntax = 0x00000001;
    enum DEC_Division_by_zero = 0x00000002;
    enum DEC_Division_impossible = 0x00000004;
    enum DEC_Division_undefined = 0x00000008;
    enum DEC_Insufficient_storage = 0x00000010; /* [when malloc fails]  */
    enum DEC_Inexact = 0x00000020;
    enum DEC_Invalid_context = 0x00000040;
    enum DEC_Invalid_operation = 0x00000080;
    static if (DECSUBSET)
    {
        enum DEC_Lost_digits = 0x00000100;
    }
    enum DEC_Overflow = 0x00000200;
    enum DEC_Clamped = 0x00000400;
    enum DEC_Rounded = 0x00000800;
    enum DEC_Subnormal = 0x00001000;
    enum DEC_Underflow = 0x00002000;
}
else
{
    /* IEEE flags only */
    enum DEC_Conversion_syntax = 0x00000010;
    enum DEC_Division_by_zero = 0x00000002;
    enum DEC_Division_impossible = 0x00000010;
    enum DEC_Division_undefined = 0x00000010;
    enum DEC_Insufficient_storage = 0x00000010; /* [when malloc fails]  */
    enum DEC_Inexact = 0x00000001;
    enum DEC_Invalid_context = 0x00000010;
    enum DEC_Invalid_operation = 0x00000010;
    static if (DECSUBSET)
    {
        enum DEC_Lost_digits = 0x00000000;
    }
    enum DEC_Overflow = 0x00000008;
    enum DEC_Clamped = 0x00000000;
    enum DEC_Rounded = 0x00000000;
    enum DEC_Subnormal = 0x00000000;
    enum DEC_Underflow = 0x00000004;
}

enum DEC_IEEE_754_Division_by_zero = DEC_Division_by_zero;
static if (DECSUBSET)
{
    enum DEC_IEEE_754_Inexact = (DEC_Inexact | DEC_Lost_digits);
}
else
{
    enum DEC_IEEE_754_Inexact = DEC_Inexact;
}

enum DEC_IEEE_754_Invalid_operation = (DEC_Conversion_syntax | DEC_Division_impossible
            | DEC_Division_undefined | DEC_Insufficient_storage
            | DEC_Invalid_context | DEC_Invalid_operation);
enum DEC_IEEE_754_Overflow = (DEC_Overflow);
enum DEC_IEEE_754_Underflow = (DEC_Underflow);

/* flags which are normally errors (result is qNaN, infinite, or 0) */
enum DEC_Errors = (DEC_IEEE_754_Division_by_zero
            | DEC_IEEE_754_Invalid_operation | DEC_IEEE_754_Overflow | DEC_IEEE_754_Underflow);
/* flags which cause a result to become qNaN                        */
enum DEC_NaNs = DEC_IEEE_754_Invalid_operation;

struct DecContext
{
    int digits; /* working precision */
    int emax; /* maximum positive exponent */
    int emin; /* minimum negative exponent */
    Rounding round; /* rounding mode */
    uint traps; /* trap-enabler flags */
    uint status; /* status flags */
    ubyte clamp; /* flag: apply IEEE exponent clamp */
    static if (DECSUBSET)
    {
        ubyte extended; /* flag: special-values allowed    */
    }
}

void decContextDefault(ref DecContext context, int kind)
{
    // set defaults...
    context.digits = 9; // 9 digits
    context.emax = DEC_MAX_EMAX; // 9-digit exponents
    context.emin = DEC_MIN_EMIN; // .. balanced
    context.round = Rounding.DEC_ROUND_HALF_UP; // 0.5 rises
    context.traps = DEC_Errors; // all but informational
    context.status = 0; // cleared
    context.clamp = 0; // no clamping
    static if (DECSUBSET)
    {
        context.extended = 0; // cleared
    }
    switch (kind)
    {
    case DEC_INIT_BASE:
        // [use defaults]
        break;
    case DEC_INIT_DECIMAL32:
        context.digits = 7; // digits
        context.emax = 96; // Emax
        context.emin = -95; // Emin
        context.round = Rounding.DEC_ROUND_HALF_EVEN; // 0.5 to nearest even
        context.traps = 0; // no traps set
        context.clamp = 1; // clamp exponents
        static if (DECSUBSET)
        {
            context.extended = 1; // set
        }
        break;
    case DEC_INIT_DECIMAL64:
        context.digits = 16; // digits
        context.emax = 384; // Emax
        context.emin = -383; // Emin
        context.round = Rounding.DEC_ROUND_HALF_EVEN; // 0.5 to nearest even
        context.traps = 0; // no traps set
        context.clamp = 1; // clamp exponents
        static if (DECSUBSET)
        {
            context.extended = 1; // set
        }
        break;
    case DEC_INIT_DECIMAL128:
        context.digits = 34; // digits
        context.emax = 6144; // Emax
        context.emin = -6143; // Emin
        context.round = Rounding.DEC_ROUND_HALF_EVEN; // 0.5 to nearest even
        context.traps = 0; // no traps set
        context.clamp = 1; // clamp exponents
        static if (DECSUBSET)
        {
            context.extended = 1; // set
        }
        break;

    default: // invalid Kind
        // use defaults, and ..
        decContextSetStatus(context, DEC_Invalid_operation); // trap
    }
}

static immutable ubyte[10] resmap = [0, 3, 3, 3, 3, 5, 7, 7, 7, 7];
void decSetCoeff(ref Decimal dn, ref DecContext set, decNumberuint* lsu, int len,
        int* residue, uint* status)
{
    int discard; // number of digits to discard
    uint cut; // cut point in uint
    decNumberuint* up; // work
    decNumberuint* target; // ..
    int count; // ..
    static if (DECDPUN <= 4)
    {
        uint temp; // ..
    }

    discard = len - set.digits; // digits to discard
    if (discard <= 0)
    { // no digits are being discarded
        if (&dn.lsu[0] != lsu)
        { // copy needed
            // copy the coefficient array to the result number; no shift needed
            count = len; // avoids D2U
            up = lsu;
            for (target = &dn.lsu[0]; count > 0; target++, up++, count -= DECDPUN)
                *target = *up;
            dn.digits = len; // set the new length
        }
        // dn.exponent and residue are unchanged, record any inexactitude
        if (*residue != 0)
            *status |= (DEC_Inexact | DEC_Rounded);
        return;
    }

    // some digits must be discarded ...
    dn.exponent += discard; // maintain numerical value
    *status |= DEC_Rounded; // accumulate Rounded status
    if (*residue > 1)
        *residue = 1; // previous residue now to right, so reduce

    if (discard > len)
    { // everything, +1, is being discarded
        // guard digit is 0
        // residue is all the number [NB could be all 0s]
        if (*residue <= 0)
        { // not already positive
            count = len; // avoids D2U
            for (up = lsu; count > 0; up++, count -= DECDPUN)
                if (*up != 0)
                { // found non-0
                    *residue = 1;
                    break; // no need to check any others
                }
        }
        if (*residue != 0)
            *status |= DEC_Inexact; // record inexactitude
        *(dn.lsu).ptr = 0; // coefficient will now be 0
        dn.digits = 1; // ..
        return;
    } // total discard

    // partial discard [most common case]
    // here, at least the first (most significant) discarded digit exists

    // spin up the number, noting residue during the spin, until get to
    // the uint with the first discarded digit.  When reach it, extract
    // it and remember its position
    count = 0;
    for (up = lsu;; up++)
    {
        count += DECDPUN;
        if (count >= discard)
            break; // full ones all checked
        if (*up != 0)
            *residue = 1;
    } // up

    // here up -> uint with first discarded digit
    cut = discard - (count - DECDPUN) - 1;
    if (cut == DECDPUN - 1)
    { // unit-boundary case (fast)
        uint half = cast(uint) powers[DECDPUN] >> 1;
        // set residue directly
        if (*up >= half)
        {
            if (*up > half)
                *residue = 7;
            else
                *residue += 5; // add sticky bit
        }
        else
        { // <half
            if (*up != 0)
                *residue = 3; // [else is 0, leave as sticky bit]
        }
        if (set.digits <= 0)
        { // special for Quantize/Subnormal :-(
            *(dn.lsu).ptr = 0; // .. result is 0
            dn.digits = 1; // ..
        }
        else
        { // shift to least
            count = set.digits; // now digits to end up with
            dn.digits = count; // set the new length
            up++; // move to next
            // on unit boundary, so shift-down copy loop is simple
            for (target = &dn.lsu[0]; count > 0; target++, up++, count -= DECDPUN)
                *target = *up;
        }
    } // unit-boundary case

    else
    { // discard digit is in low digit(s), and not top digit
        uint discard1; // first discarded digit
        uint quot, rem; // for divisions
        if (cut == 0)
            quot = *up; // is at bottom of unit
        else /* cut>0 */
        { // it's not at bottom of unit
            static if (DECDPUN <= 4)
            {
                quot = QUOT10(*up, cut);
                rem = *up - quot * powers[cut];
            }
            else
            {
                rem = *up % powers[cut];
                quot = *up / powers[cut];
            }
            if (rem != 0)
                *residue = 1;
        }
        // discard digit is now at bottom of quot
        static if (DECDPUN <= 4)
        {
            temp = (quot * 6554) >> 16; // fast /10
            // Vowels algorithm here not a win (9 instructions)
            discard1 = quot - (temp * 10);
            quot = temp;
        }
        else
        {
            discard1 = quot % 10;
            quot = quot / 10;
        }
        // here, discard1 is the guard digit, and residue is everything
        // else [use mapping array to accumulate residue safely]
        *residue += resmap[discard1];
        cut++; // update cut
        // here: up -> uint of the array with bottom digit
        //       cut is the division point for each uint
        //       quot holds the uncut high-order digits for the current unit
        if (set.digits <= 0)
        { // special for Quantize/Subnormal :-(
            *(dn.lsu).ptr = 0; // .. result is 0
            dn.digits = 1; // ..
        }
        else
        { // shift to least needed
            count = set.digits; // now digits to end up with
            dn.digits = count; // set the new length
            // shift-copy the coefficient array to the result number
            for (target = &dn.lsu[0];; target++)
            {
                *target = cast(ushort) quot;
                count -= (DECDPUN - cut);
                if (count <= 0)
                    break;
                up++;
                quot = *up;
                static if (DECDPUN <= 4)
                {
                    quot = QUOT10(quot, cut);
                    rem = *up - quot * powers[cut];
                }
                else
                {
                    rem = quot % powers[cut];
                    quot = quot / powers[cut];
                }
                *target = cast(ushort)(*target + rem * powers[DECDPUN - cut]);
                count -= cut;
                if (count <= 0)
                    break;
            } // shift-copy loop
        } // shift to least
    } // not unit boundary

    if (*residue != 0)
        *status |= DEC_Inexact; // record inexactitude
    return;
}

void decContextSetStatus(ref DecContext context, uint status)
{
    context.status |= status;
    //TODO
    //if (status & context.traps)
    //    raise(SIGFPE);
}

struct Decimal
{
    // Count of digits in the coefficient; >0
    int digits;
    // Unadjusted exponent, unbiased, in range: -1999999997 through 999999999
    int exponent;
    // Indicator bits (see above)
    ubyte bits;
    // Coefficient, from least significant unit
    decNumberuint[DECNUMUNITS] lsu;

    this(T)(T val, DecContext set) if (isNumeric!T)
    {

    }

    this(string str, DecContext set)
    {
        int exponent = 0; // working exponent [assume 0]
        ubyte bits = 0; // working flags [assume +ve]
        decNumberuint* res; // where result will be built
        enum buffSize = SD2U(DECBUFFER + 9);
        decNumberuint[buffSize] resbuff; // local buffer in case need temporary
        // [+9 allows for ln() constants]
        decNumberuint* allocres = null; // -> allocated result, iff allocated
        int d = 0; // count of digits found in decimal part
        const(char)* dotchar = null; // where dot was found
        const(char)* cfirst = str.ptr; // -> first character of decimal part
        const(char)* last = null; // -> last digit of decimal part
        const(char)* c; // work
        decNumberuint* up; // ..
        static if (DECDPUN > 1)
        {
            long cut, _out;
        }
        int residue; // rounding residue
        uint status = 0; // error code

        static if (DECCHECK)
        {
            if (decCheckOperands(DECUNRESU, DECUNUSED, DECUNUSED, set))
                return Decimal.init;
        }

        // status & malloc protection
        do
        {
            for (c = str.ptr;; c++)
            { // -> input character
                if (*c >= '0' && *c <= '9')
                { // test for Arabic digit
                    last = c;
                    d++; // count of real digits
                    continue; // still in decimal part
                }
                if (*c == '.' && dotchar == null)
                { // first '.'
                    dotchar = c; // record offset into decimal part
                    if (c == cfirst)
                        cfirst++; // first digit must follow
                    continue;
                }
                if (c == str.ptr)
                { // first in string...
                    if (*c == '-')
                    { // valid - sign
                        cfirst++;
                        bits = DECNEG;
                        continue;
                    }
                    if (*c == '+')
                    { // valid + sign
                        cfirst++;
                        continue;
                    }
                }
                // *c is not a digit, or a valid +, -, or '.'
                break;
            } // c

            if (last == null)
            { // no digits yet
                status = DEC_Conversion_syntax; // assume the worst
                if (*c == '\0')
                    break; // and no more to come...
                static if (DECSUBSET)
                {
                    // if subset then infinities and NaNs are not allowed
                    if (!set.extended)
                        break; // hopeless
                }
                // Infinities and NaNs are possible, here
                if (dotchar != null)
                    break; // .. unless had a dot
                if (decBiStr(c, "infinity", "INFINITY") || decBiStr(c, "inf", "INF"))
                {
                    this.bits = bits | DECINF;
                    status = 0; // is OK
                    break; // all done
                }
                // a NaN expected
                // 2003.09.10 NaNs are now permitted to have a sign
                this.bits = bits | DECNAN; // assume simple NaN
                if (*c == 's' || *c == 'S')
                { // looks like an sNaN
                    c++;
                    this.bits = bits | DECSNAN;
                }
                if (*c != 'n' && *c != 'N')
                    break; // check caseless "NaN"
                c++;
                if (*c != 'a' && *c != 'A')
                    break; // ..
                c++;
                if (*c != 'n' && *c != 'N')
                    break; // ..
                c++;
                // now either nothing, or nnnn payload, expected
                // -> start of integer and skip leading 0s [including plain 0]
                for (cfirst = c; *cfirst == '0';)
                    cfirst++;
                if (*cfirst == '\0')
                { // "NaN" or "sNaN", maybe with all 0s
                    status = 0; // it's good
                    break; // ..
                }
                // something other than 0s; setup last and d as usual [no dots]
                for (c = cfirst;; c++, d++)
                {
                    if (*c < '0' || *c > '9')
                        break; // test for Arabic digit
                    last = c;
                }
                if (*c != '\0')
                    break; // not all digits
                if (d > set.digits - 1)
                {
                    // [NB: payload in a decNumber can be full length unless
                    // clamped, in which case can only be digits-1]
                    if (set.clamp)
                        break;
                    if (d > set.digits)
                        break;
                } // too many digits?
                // good; drop through to convert the integer to coefficient
                status = 0; // syntax is OK
                bits = this.bits; // for copy-back
            } // last==null

            else if (*c != '\0')
            { // more to process...
                // had some digits; exponent is only valid sequence now
                ubyte nege; // 1=negative exponent
                const(char)* firstexp; // -> first significant exponent digit
                status = DEC_Conversion_syntax; // assume the worst
                if (*c != 'e' && *c != 'E')
                    break;
                /* Found 'e' or 'E' -- now process explicit exponent */
                // 1998.07.11: sign no longer required
                nege = 0;
                c++; // to (possible) sign
                if (*c == '-')
                {
                    nege = 1;
                    c++;
                }
                else if (*c == '+')
                    c++;
                if (*c == '\0')
                    break;

                for (; *c == '0' && *(c + 1) != '\0';)
                {
                    c++; // strip insignificant zeros
                }
                firstexp = c; // save exponent digit place
                for (;; c++)
                {
                    if (*c < '0' || *c > '9')
                    {
                        break; // not a digit
                    }
                    exponent = (exponent * 10) + (cast(int)*c) - (cast(int) '0');
                } // c
                // if not now on a '\0', *c must not be a digit
                if (*c != '\0')
                    break;

                // (this next test must be after the syntax checks)
                // if it was too long the exponent may have wrapped, so check
                // carefully and set it to a certain overflow if wrap possible
                if (c >= firstexp + 9 + 1)
                {
                    if (c > firstexp + 9 + 1 || *firstexp > '1')
                        exponent = DECNUMMAXE * 2;
                    // [up to 1999999999 is OK, for example 1E-1000000998]
                }
                if (nege)
                    exponent = -exponent; // was negative
                status = 0; // is OK
            } // stuff after digits

            // Here when whole string has been inspected; syntax is good
            // cfirst->first digit (never dot), last->last digit (ditto)

            // strip leading zeros/dot [leave final 0 if all 0's]
            if (*cfirst == '0')
            { // [cfirst has stepped over .]
                for (c = cfirst; c < last; c++, cfirst++)
                {
                    if (*c == '.')
                        continue; // ignore dots
                    if (*c != '0')
                        break; // non-zero found
                    d--; // 0 stripped
                } // c
                static if (DECSUBSET)
                {
                    // make a rapid exit for easy zeros if !extended
                    if (*cfirst == '0' && !set.extended)
                    {
                        Decimal.init; // clean result
                        break; // [could be return]
                    }
                }
            } // at least one leading 0

            // Handle decimal point...
            if (dotchar != null && dotchar < last) // non-trailing '.' found?
                exponent -= (last - dotchar); // adjust exponent
            // [we can now ignore the .]

            // OK, the digits string is good.  Assemble in the decNumber, or in
            // a temporary units array if rounding is needed
            if (d <= set.digits)
            {
                res = &this.lsu[0]; // fits into supplied decNumber
            }
            else
            { // rounding needed
                ulong needbytes = D2U(d) * decNumberuint.sizeof; // bytes needed
                res = &resbuff[0]; // assume use local buffer
                if (needbytes > (cast(int) typeof(resbuff).sizeof))
                { // too big for local
                    allocres = cast(decNumberuint*) malloc(needbytes);
                    if (allocres == null)
                    {
                        status |= DEC_Insufficient_storage;
                        break;
                    }
                    res = allocres;
                }
            }
            // res now -> number lsu, buffer, or allocated storage for decNumberuint array

            // Place the coefficient into the selected decNumberuint array
            // [this is often 70% of the cost of this function when DECDPUN>1]
            static if (DECDPUN > 1)
            {
                _out = 0; // accumulator
                up = res + D2U(d) - 1; // -> msu
                cut = d - (up - res) * DECDPUN; // digits in top unit
                for (c = cfirst;; c++)
                { // along the digits
                    if (*c == '.')
                        continue; // ignore '.' [don't decrement cut]
                    _out = (_out * 10) + (cast(int)*c) - 0U;
                    if (c == last)
                        break; // done [never get to trailing '.']
                    cut--;
                    if (cut > 0)
                        continue; // more for this unit
                    *up = cast(decNumberuint) _out; // write unit
                    up--; // prepare for unit below..
                    cut = DECDPUN; // ..
                    _out = 0; // ..
                } // c
                *up = cast(decNumberuint) _out; // write lsu
            }
            else
            {
                // DECDPUN==1
                up = res; // -> lsu
                for (c = last; c >= cfirst; c--)
                { // over each character, from least
                    if (*c == '.')
                        continue; // ignore . [don't step up]
                    *up = cast(decNumberuint)((cast(int)*c) - 0U);
                    up++;
                } // c
            }

            this.bits = bits;
            this.exponent = exponent;
            this.digits = d;

            // if not in number (too long) shorten into the number
            if (d > set.digits)
            {
                residue = 0;
                decSetCoeff(this, set, res, d, &residue, &status);
                // always check for overflow or subnormal and round as needed
                decFinalize(this, set, &residue, &status);
            }
            else
            { // no rounding, but may still have overflow or subnormal
                // [these tests are just for performance; finalize repeats them]
                if ((this.exponent - 1 < set.emin - this.digits)
                        || (this.exponent - 1 > set.emax - set.digits))
                {
                    residue = 0;
                    decFinalize(dn, set, &residue, &status);
                }
            }
            // decNumberShow(dn);
        }
        while (0); // [for break]

        if (allocres != null)
            free(allocres); // drop any storage used
        if (status != 0)
            decStatus(dn, status, set);
    }

    bool opEquals(T)(T f) if (isFloatingPoint!T)
    {
        return false;
    }
}

// construction
unittest
{
    DecContext set;
    decContextDefault(set, DEC_INIT_BASE);

    auto a = Decimal("1.0", set);
    assert(a == 1.0);

    auto b = Decimal("0001.0000", set);
    assert(b == 1.0);

    auto c = Decimal(1.0, set);
    assert(c == 1.0);

    auto d = Decimal(1, set);
    assert(d == 1.0);
}
